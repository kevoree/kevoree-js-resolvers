'use strict';

const Resolver = require('kevoree-commons').Resolver,
  fs = require('fs'),
  path = require('path'),
  util = require('util'),
  mkdirp = require('mkdirp'),
  execNpm = require('exec-npm'),
  exists = require('./exists');

const DEFAULT_PKGJSON = JSON.stringify({
  name: 'kevoree-local-deployunits',
  version: '0.0.0',
  description: 'This file has been generated by Kevoree in order to prevent npm from outputing log warnings',
  private: true
}, null, 2);

function NPMResolver(modulesPath, logger) {
  Resolver.call(this, modulesPath, logger);
  this.log.debug(this.toString(), 'DeployUnits install directory: ' + this.modulesPath);
  fs.writeFileSync(path.resolve(this.modulesPath, 'package.json'), DEFAULT_PKGJSON, 'utf8');
}

util.inherits(NPMResolver, Resolver);

NPMResolver.prototype.resolve = function (deployUnit, forceInstall, callback) {
  if (!callback) {
    // "forceInstall" parameter is not specified (optional)
    callback = forceInstall;
  }

  var pkgPath = path.resolve(this.modulesPath, 'node_modules', deployUnit.name),
    options = {
      name: deployUnit.name + '@' + deployUnit.version,
      path: this.modulesPath
    };

  mkdirp(this.modulesPath, function (err) {
    if (err) {
      callback(err);
    } else {
      // lets try to check if the current directory contains the library
      // so that we can install it with the local content
      fs.readFile(path.resolve('.', 'package.json'), function (err, data) {
        if (err) {
          // unable to require current directory package.json, lets try to resolve module from npm registry
          this.npmLoad(pkgPath, options, callback);
        } else {
          var pkg = JSON.parse(data);
          if (pkg.name === deployUnit.name) {
            // current directory contains the library we want to resolve
            options.name = path.resolve('.');
            this.npmLoad(pkgPath, options, callback);
          } else {
            // unable to find module locally, lets try to resolve it from npm registry
            this.npmLoad(pkgPath, options, callback);
          }
        }
      }.bind(this));
    }
  }.bind(this));
};

NPMResolver.prototype.uninstall = function (deployUnit, callback) {
  execNpm(['uninstall', deployUnit.name, '--prefix=' + this.modulesPath], {
    stdio: ['ignore', 'ignore', process.stderr]
  }, function (err) {
    if (err) {
      callback(new Error('NPMResolver failed to uninstall ' + deployUnit.name));
    } else {
      callback();
    }
  });
};

NPMResolver.prototype.npmLoad = function (pkgPath, options, callback) {
  exists(options.name, options.path, function (err, exists) {
    if (err) {
      callback(err);
    } else {
      if (exists) {
        // do not re-install an already installed module
        this.log.debug(this.toString(), options.name + ' found in ' + options.path);
        this.loadClass(pkgPath, callback);
      } else {
        this.log.debug(this.toString(), 'Installing ' + options.name + ' ...');
        execNpm(['install', options.name, '--prefix=' + options.path], {
          stdio: ['ignore', 'ignore', process.stderr]
        }, function (err) {
          if (err) {
            this.log.error(this.toString(), err.message);
            callback(new Error('Resolve failed for DeployUnit ' + options.name));
            return;
          }

          this.loadClass(pkgPath, callback);
        }.bind(this));
      }
    }
  }.bind(this));
};

NPMResolver.prototype.loadClass = function (pkgPath, callback) {
  // resolve deployUnit module (require it) and call callback
  delete require.cache[pkgPath];
  var KClass = require(pkgPath);
  callback(null, KClass);
};

NPMResolver.prototype.toString = function () {
  return 'NPMResolver';
};

module.exports = NPMResolver;
